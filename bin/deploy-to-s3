#!/bin/sh
#
# Package S3 uploader
#
# Usage: bin/deploy-to-s3 [<package_name>, ...]
#
# If you pass package names, it will look for specific packages on the output
# directory and will try to build them. Otherwise, it will upload all packages
# in that directory.
#
# Environment:
#   (Optional) AWS_PROFILE => Set which AWS profile is going to be used to
#     perform the S3 operations. This is recommended over using the access keys
#     directly.
#   (Optional) AWS_ACCESS_KEY_ID => If not using AWS profiles, this should
#     point to the key created by IAM.
#   (Optional) AWS_SECRET_ACCESS_KEY => If not using AWS profiles, this should
#     be the access secret of your key.
#   (Required) AWS_S3_PACKAGES_BUCKET_NAME => The bucket name to which you want to push
#     the packages to. Ensure that you have write access to it.
#   (Required) REPO_NAME => The name of the repository file that you want to
#     add your built packages to.

main() {
  # cd to root path
  cd "$(dirname "$0")/.." || exit;

  # Parameters
  packages=$*

  # This is the global var with the output variable. All uploaded files are
  # relative to this directory.
  OUTPUT_PATH="$(pwd)/output"

  if [ -z "$AWS_S3_PACKAGES_BUCKET_NAME" ]; then
    error "Please, set the S3 Bucket using the variable \$AWS_S3_PACKAGES_BUCKET_NAME"
    exit 1
  fi

  if [ -z "$REPO_NAME" ]; then
    error "Please, set the name of your repository with the var \$REPO_NAME"
    exit 1
  fi

  if [ $# -eq 0 ]; then
    upload_multiple_packages "$(ls -1 src)"
  else
    upload_multiple_packages "$packages"
  fi
}

upload_multiple_packages() {
  list=$*

  for package in $list; do
    upload_package "$package"
  done

  upload_repo_db
}

upload_package() {
  package=$1

  # Set the output folder of the built package
  export PKGDEST="$OUTPUT_PATH/packages"

  # Get the name of the built package
  built_pkg_file=$(cd "src/$package" && makepkg --packagelist)
  built_pkg_basename="${built_pkg_file#$PKGDEST/}"

  if ! [ -f "$built_pkg_file" ]; then
    error "The package '$package' is not built!"
    exit 1
  fi

  # Upload it!
  upload_artifact packages "$built_pkg_basename"

  # Delete the old versions of that package on the remote
  delete_old_versions "$package" "$built_pkg_basename"
}

upload_repo_db() {
  files="$REPO_NAME.db $REPO_NAME.db.tar.gz $REPO_NAME.files $REPO_NAME.files.tar.gz"

  for file in $files; do
    upload_artifact db "$file"
  done
}

delete_old_versions() {
  package_name=$1
  built_package_name=$2

  packages_to_delete=$(aws s3 ls "$AWS_S3_PACKAGES_BUCKET_NAME/$package_name-" | awk "!/$built_package_name/ { print \$4 }")

  for filename in $packages_to_delete; do
    success "Removing old package $filename"
    aws s3 rm "s3://$AWS_S3_PACKAGES_BUCKET_NAME/$filename" > /dev/null
    info "File $filename removed from repository"
  done
}

# This function uploads an artifact at the `output` path to the S3 bucket.
# Please notice that the file will be uploaded to the root path of the bucket
# plus the name of the file (second argument). The folder argument only
# specifies where to find the file.
#
# Arguments
#  1 - This is the folder where to find the file
#  2 - This is the file that you want to upload
upload_artifact() {
  folder=$1
  file=$2

  # Avoid re-uploading packages that are already there
  s3_md5=$(aws s3api head-object --bucket "$AWS_S3_PACKAGES_BUCKET_NAME" --key "$file" \
    --query ETag --output text 2> /dev/null | grep --extended --only-match \
    '[a-f0-9]{32}'); status=$?

  if [ $status -eq 0 ]; then
    file_md5=$(md5sum "$OUTPUT_PATH/$folder/$file" | \
      grep --extended --only-match '[a-f0-9]{32}')

    if [ "$s3_md5" = "$file_md5" ]; then
      warn "File '$folder/$file' already uploaded."
      return
    fi
  fi

  success "Uploading file $folder/$file"
  aws s3 cp "$OUTPUT_PATH/$folder/$file" "s3://$AWS_S3_PACKAGES_BUCKET_NAME/$file" > /dev/null
  status=$?

  if [ $status -eq 0 ]; then
    info "File '$folder/$file' uploaded"
  else
    error "The file '$folder/$file' could not be uploaded."
    exit 1
  fi
}

# Print colorful notice messages to the console
normal="\\e[0m"
bold="\\e[1m"
blue="\\e[34m"
green="\\e[32m"
red="\\e[31m"
orange="\\e[33m"
error() { printf "${bold}${red}==> ERROR:${normal}${bold} ${*}${normal}\\n"; }
success() { printf "${bold}${green}==>${normal}${bold} ${*}${normal}\\n"; }
warn() { printf "${bold}${orange}==> WARNING:${normal}${bold} ${*}${normal}\\n"; }
info() { printf "${bold}${blue}  ->${normal}${bold} ${*}${normal}\\n"; }

# shellcheck disable=SC2068
main $@
