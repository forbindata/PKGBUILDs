#!/bin/sh
#
# Arch Package Builder
#
# Usage: bin/build [<package_name>, ...]
#
# If you pass package names, it will look for specific packages on src
# directory and will try to build them. Otherwise, it will build all packages
# in that directory.
#
# Environment:
#   (Required) REPO_NAME => The name of the repository file that you want to
#     add your built packages to.
#   (Optional) DISABLE_SIGNATURES => Whether we want to disable build
#     signatures. This is not recommended for production.

main() {
  # cd to root path
  cd "$(dirname "$0")/.." || exit

  # shellcheck disable=2039,1091
  source lib/messages.sh

  # Checks presence of required params
  validate_env

  # Parameters
  packages=$*

  # This is the global var with the output variable. All built files are
  # stored in this directory.
  OUTPUT_PATH="$(pwd)/output"

  if [ $# -eq 0 ]; then
    build_multiple "$(ls -1 src)"
  else
    build_multiple "$packages"
  fi
}

# Checks the environment for the required variables and then stops if they are
# not found.
validate_env() {
  if [ -z "$REPO_NAME" ]; then
    error "Please, set the name of your repository with the var \$REPO_NAME"
    exit 1
  fi
}

# Build multiple packages if you provide a list
build_multiple() {
  list=$*

  for package in $list; do
    build "$package"
  done
}

# Build packages on `src` folder
build() {
  package=$1
  pkg_path="src/$package"

  if ! [ -d "$pkg_path" ]; then
    error "Package $package is not found!"
    exit 1
  fi

  # Set the output folder of the built package
  export PKGDEST="$OUTPUT_PATH/packages"

  # Add the signature flag
  if [ -z "$DISABLE_SIGNATURES" ]; then
    sign_flag_pkg="--sign"
    sign_flag_repo="--sign --verify"
  else
    sign_flag_pkg=""
    sign_flag_repo=""
  fi

  # Build the package
  ( cd "$pkg_path" && \
    makepkg --clean --force --syncdeps --needed --noconfirm $sign_flag_pkg )

  # Get the name of the built package
  built_pkg_file=$(cd "$pkg_path" && makepkg --packagelist)
  built_pkg_basename="${built_pkg_file#$PKGDEST/}"

  # Then add this package to the repository
  ( cd "$PKGDEST" && repo-add --new $sign_flag_repo \
    "$OUTPUT_PATH/db/$REPO_NAME.db.tar.gz" "$built_pkg_basename" )

  # Remove old versions of this package locally
  sweep_old_packages "$package" "$built_pkg_basename"
}

sweep_old_packages() {
  package=$1
  current_package_file=$2
  output="$OUTPUT_PATH/packages"

  # shellcheck disable=2010
  old_packages=$(ls -1 "$output" | grep "$package" | grep -v "$current_package_file")
  for old_pkg in $old_packages; do
    rm "$output/$old_pkg"
    warn "Removed old package $old_pkg"
  done
}

# shellcheck disable=SC2068
main $@
